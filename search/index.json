[{"content":" 在 Windows 下，搭建开发环境一直是一个复杂且困难的问题。由于没有一个统一的标准，导致各种开发环境的安装方式差异巨大，需要付出很多不必要的时间成本。而 Scoop 可以帮助你统一安装并管理常见的开发软件，省去了手动下载安装，配置环境变量等繁琐步骤。\n安装Scoop 打开PowerShell，输入以下指令\n1 2 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser # 设置PowerShell执行策略 irm get.scoop.sh | iex # 安装Scoop 安装GCC（C/C++ 编译器） 安装gcc\n1 scoop install gcc 安装完成后，可以测试是否安装以及配置成功\n1 gcc --version 如果显示版本号，说明已经安装成功\n安装VSCode 方法一 直接在官网安装 略\n方法二 使用Scoop安装 如果你通过方法一安装请忽略这一步骤\n1 scoop install vscode 在VSCode配置C/C++ 插件 点击扩展(Extensions) $ \\rightarrow $ 搜索C/C++ $ \\rightarrow $ 安装插件 打开命令面板(Ctrl+Shift+P): 搜索 C/C++: Edit Configurations (UI) 或 C/C++: Edit Configurations (JSON) 设置**\u0026ldquo;compilerPath\u0026rdquo;**为你的GCC路径，例如 1 \u0026#34;compilerPath\u0026#34;: \u0026#34;C:/Users/你的用户名/scoop/apps/gcc/current/bin/g++.exe\u0026#34; 测试 补充，如何使用Scoop官方文档和快速入门\n","date":"2025-09-14T21:03:39+08:00","permalink":"https://ZihaoLin111.github.io/blog/p/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8scoop%E9%85%8D%E7%BD%AEc-/","title":"如何使用Scoop配置c++"},{"content":"To be continued ","date":"2025-09-14T11:11:24+08:00","permalink":"https://ZihaoLin111.github.io/blog/p/mit18.01calculus%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","title":"MIT18.01Calculus学习日记"},{"content":"以此博客记录我的CS61A学习过程。由于本人一定程度上仅为计算机初学者，准确来说是还没入学的准大一新生因此本博客以记录个人感想和学习所得为主，故没法像其他博客起到知识传递和解答问题的效果，但我会仅可能记录下自己学习过程中遇到的问题，或许能够帮助到看到这篇博客的人\n注：本人使用的为Fall2024的课程以及作业 课程网站:CS61A\n课程网站(页面备份):Fall2024\n课程作业:CS61A-Assignments\n课程视频:Spring2024\nJuly 4, 2025 准确来说，今天并不是开始学习的第一天，再此之前已经学习了Lecture1和Lecture2的课程，今天在忙完高考志愿填报的事后终于闲了下来，于是便开始以日记的形式记录学习过程。\n今天听了Lecture3 Control的课程，这段时间学习下来我认为CS61A不同于我以往在中学学习的计算机课程最大的不同是CS61A着重于why，也就是这段代码的实现经历了什么；而中学时的课程更多的是how，教会学生如何实现便点到为止，而为何实现却很少提及，大多考自己理解，而学测也不会考为何实现。\nCS61A的作业我认为也是课程的亮点之一，刚刚完成了hw01和lab01，承认这两者作为第一天的作业并不是很难，但也绝不是丝毫不要思考的简单题目(我做hw01的时候就因为轻视了题目难度，结果每道题ok的时候都报了错哈哈)\n记录一道自己在lab01的quiz里面做错的题\nQ: How do you prevent the ok autograder from interpreting print statements as output?\nChoose the number of the correct choice:\n0 ) You don\u0026rsquo;t need to do anything, ok only looks at returned values, not printed values\n1 ) Print with \u0026lsquo;DEBUG:\u0026rsquo; at the front of the outputted line\n2 ) Print with # at the front of the outputted line\ncorrect answer: 1 )\n来自ChatGPT的解答：\n输入输出机制\n返回值检查： ok autograder 会检查程序的返回值来判断是否正确执行。例如，作业中可能有一个函数 add(a, b)，它应该返回 a + b 的值。评分系统会调用该函数并验证返回值是否与预期一致。\n打印输出： 默认情况下，ok autograder 会忽略 print 语句的输出，因为它只关心返回值。如果有调试信息打印出来，最好使用特殊前缀（如 DEBUG:）或者注释符号（如 #），以避免误判为程序的正常输出。\nJuly 6, 2025 昨天听了Lecture 4 Higher-Order Functions然后顺手把hw02做了，后来考虑时间已晚于是就把project hog放在了第二天\nproject hog做了5个多小时，但是在读代码和写代码的过程中感觉自己的理解代码的能力提升了很多；而且完成这个项目，然后成功运行之后感受到了一种前所未有的成就感。我想这两点是CS61A作为UC Berkeley大一课程所能很大程度帮助提升学生能力的地方，阅读高质量的代码十分有益于计算机新手，同时完成项目的成就感能够激励我们继续后面的学习\n另外值得一提的是hw02中的一些题目中解法为Currying，这是我之前从未见到的，也是我在这个lecture收获最大的，不过这几道题我最初并没能想到Currying的解法于是使用了return一个判断的思路\ne.g.\n1 2 3 4 5 6 7 8 9 10 11 12 13 def summation_using_accumulate(n, term): \u0026#34;\u0026#34;\u0026#34;Returns the sum: term(1) + ... + term(n), using accumulate. \u0026gt;\u0026gt;\u0026gt; summation_using_accumulate(5, square) # square(1) + square(2) + ... + square(4) + square(5) 55 \u0026gt;\u0026gt;\u0026gt; summation_using_accumulate(5, triple) # triple(1) + triple(2) + ... + triple(4) + triple(5) 45 \u0026gt;\u0026gt;\u0026gt; # This test checks that the body of the function is just a return statement. \u0026gt;\u0026gt;\u0026gt; import inspect, ast \u0026gt;\u0026gt;\u0026gt; [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body] [\u0026#39;Expr\u0026#39;, \u0026#39;Return\u0026#39;] \u0026#34;\u0026#34;\u0026#34; return n \u0026gt; 0 and term(n) + summation_using_accumulate(n - 1, term) 判断n \u0026gt; 0 可以限制递归的边界，而当判断为False时，就会返回0的值，前一级的结果就会加0。自认为也是一种解决方法\n当然题干里要求了using accumulate，所以我的答案并不标准合规，下面是标准答案\n1 2 3 4 5 6 7 8 9 10 11 12 13 def accumulate(fuse, start, n, term): \u0026#34;\u0026#34;\u0026#34;Return the result of fusing together the first n terms in a sequence and start. The terms to be fused are term(1), term(2), ..., term(n). The function fuse is a two-argument commutative \u0026amp; associative function. \u0026#34;\u0026#34;\u0026#34; total, k = start, 1 while k \u0026lt;= n: total, k = fuse(total, term(k)), k + 1 return total def summation_using_accumulate(n, term): \u0026#34;\u0026#34;\u0026#34;Returns the sum: term(1) + ... + term(n), using accumulate.\u0026#34;\u0026#34;\u0026#34; return accumulate(add, 0, n, term) 后面几天计划出去旅游，学习估计得暂停几天，期间在飞机上路途中打算听一下3b1b的微积分视频，为后面学习MIT18.01/18.02: Calculus做准备\nJuly 26, 2025 递归好难\nJuly 31, 2025 Lecture 11 Sequences, 最简单的一集哈哈\nLab03也挺简单的，基本都是关于列表的基础题目， 40min以内就能搞定\nLecture 12 Containers 也比较简单，这两节属于为后续打基础的课\nAugust 4, 2025 前后历时3天终于完成了project cats\n其中自认为比较难的一道题是Problem7，题干如下\n我的解法及中文注释如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def minimum_mewtations(typed, source, limit): if typed == source: # 如果typed和source相等就终止，也是递归的终止 return 0 if limit \u0026lt;= 0: # 如果最小步数大于limit就结束，此时最终return的值将是limit + 1 return 1 elif len(typed) == 0 or len(source) == 0: # 同上，递归的终止 return abs(len(typed) - len(source)) elif typed[0] == source[0]: # 判断第一位是否相同，相同就继续递归，不相同就考虑如下add，remove，substitute三种情况 return minimum_mewtations(typed[1:], source[1:], limit) else: add = minimum_mewtations(typed, source[1:], limit - 1) # 添加一个字符相当于typed不变，source变为从第1位开始 remove = minimum_mewtations(typed[1:], source, limit - 1) # 删去一个字符相当于source不变，typed变为从第1位开始 substitute = minimum_mewtations(typed[1:], source[1:], limit - 1) # 替换一个字符相当于typed和source都不变，于是都变为下一位开始递归 return 1 + min(add, remove, substitute) # 取最小值 September 3, 2025 拖了好久终于把Project Ants写好了\n不得不承认通过完成一个项目能够很大程度提升对面对对象编程的理解\nSeptember 8, 2025 我认为该篇博客不应该尽局限于记录自身学习CS61A的感受，而应当聚焦于记录课程的知识点和题解，以供未来的自己和他人参考学习。故决定从今日起改变博客内容。\nLecture23 Measuring Efficiency 关于如何理解程序运行需要多长时间的问题\n如何计数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def fib(n): if n == 0 or n == 1: return n else: return fib(n - 2) + fib(n - 1) def count(f): def counted(n): counted.call_count += 1 return f(n) counted.call_count = 0 return counted \u0026#34;\u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; fib = count(fib) # 也可以通过decorator的方式实现 \u0026gt;\u0026gt;\u0026gt; fib(5) 5 \u0026gt;\u0026gt;\u0026gt; fib.call_count 15 \u0026#34;\u0026#34;\u0026#34; Memoization\n一种加速程序运行时间的技术， Idea: Remember the results that have been computed before\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def memo(f): cache = {} # Keys are arguments that map to return values def memoized(n): if n not in cache: cache[n] = f(n) return cache[n] return memoized # Same behavior as f, if f is a pure function \u0026#34;\u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; fib = count(fib) \u0026gt;\u0026gt;\u0026gt; counted_fib = fib \u0026gt;\u0026gt;\u0026gt; fib = memo(fib) \u0026gt;\u0026gt;\u0026gt; fib = count(fib) \u0026gt;\u0026gt;\u0026gt; fib(30) 832040 \u0026gt;\u0026gt;\u0026gt; fib.call_count 59 \u0026gt;\u0026gt;\u0026gt; counted_fib.call_count 31 \u0026#34;\u0026#34;” 两种计算指数的方法 $$ b^n = \\left\\{ \\begin{array}{l} 1 \\qquad\\quad\\ \\ if\\ n = 0 \\\\ b \\cdot b^{n-1} \\quad otherwise \\end{array} \\right. $$ 时间复杂度O(n), 线性时间 $$ b^n = \\left\\{ \\begin{array}{l} 1 \\qquad\\quad\\ \\ if\\ n = 0 \\\\ (b^{\\frac{1}{2}n})^{2} \\quad \\ if\\ n\\ is\\ even \\\\ b \\cdot b^{n-1} \\quad if\\ n\\ is\\ odd \\end{array} \\right. $$ 时间复杂度O(log n), 对数时间\n常见Order of Growth(时间复杂度)\nExponential growth(指数). E.g. , recursive fib Quadratic growth(二次). E.g. , overlap Linear growth(线性). E.g. , exp Logarithmic growth(对数). E.g. , exp_fast Constant growth(常数). 变量n不影响时间 详细案例参考课程视频\nThe Consumption of Space(空间复杂度)\nValues and frames in active environments consume memory\n空间复杂度衡量上述所说的执行算法所需的内存大小\nSeptember 9, 2025 Lecture24 Decomposition 模块化意味着有一些组件可以互相替换，并且通过抽象屏障分离，模块化设计的目的是实现程序不同部分关注点不同\n好处：模块化组件可以独立开发和测试，确保能解决所需解决的问题，而不必担心其他部分\nSeptember 12, 2025 Lecture28 Scheme Scheme是Lisp的一种方言，Lisp的优点在于其简洁性可以在一天之内学会\nScheme程序由表达式组成， 可以是原始的，也可以有各种组合，与Python不同，调用表达式时运算符放在里面\n1 2 3 4 \u0026gt;(quotient 10 2) 5 \u0026gt;(quotient (+ 8 7) 5) 3 Scheme部分可以说是本课程的精华, 当然这指的是后面Scheme解释器的Project\n","date":"2025-07-04T12:56:35+08:00","permalink":"https://ZihaoLin111.github.io/blog/p/cs61a%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","title":"CS61A学习日记"},{"content":"Test Hello World\nAugust 9th\n","date":"2025-06-26T12:26:16+08:00","permalink":"https://ZihaoLin111.github.io/blog/p/test/","title":"Test"}]