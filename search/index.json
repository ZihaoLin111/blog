[{"content":"以此博客记录我的CS61A学习过程。由于本人一定程度上仅为计算机初学者，准确来说是还没入学的准大一新生因此本博客以记录个人感想和学习所得为主，故没法像其他博客起到知识传递和解答问题的效果，但我会仅可能记录下自己学习过程中遇到的问题，或许能够帮助到看到这篇博客的人\n注：本人使用的为Fall2024的课程以及作业 课程网站:CS61A\n课程网站(页面备份):Fall2024\n课程作业:CS61A-Assignments\n课程视频:Spring2024\nJuly 4, 2025 准确来说，今天并不是开始学习的第一天，再此之前已经学习了Lecture1和Lecture2的课程，今天在忙完高考志愿填报的事后终于闲了下来，于是便开始以日记的形式记录学习过程。\n今天听了Lecture3 Control的课程，这段时间学习下来我认为CS61A不同于我以往在中学学习的计算机课程最大的不同是CS61A着重于why，也就是这段代码的实现经历了什么；而中学时的课程更多的是how，教会学生如何实现便点到为止，而为何实现却很少提及，大多考自己理解，而学测也不会考为何实现。\nCS61A的作业我认为也是课程的亮点之一，刚刚完成了hw01和lab01，承认这两者作为第一天的作业并不是很难，但也绝不是丝毫不要思考的简单题目(我做hw01的时候就因为轻视了题目难度，结果每道题ok的时候都报了错哈哈)\n记录一道自己在lab01的quiz里面做错的题\nQ: How do you prevent the ok autograder from interpreting print statements as output?\nChoose the number of the correct choice:\n0 ) You don\u0026rsquo;t need to do anything, ok only looks at returned values, not printed values\n1 ) Print with \u0026lsquo;DEBUG:\u0026rsquo; at the front of the outputted line\n2 ) Print with # at the front of the outputted line\ncorrect answer: 1 )\n来自ChatGPT的解答：\n输入输出机制\n返回值检查： ok autograder 会检查程序的返回值来判断是否正确执行。例如，作业中可能有一个函数 add(a, b)，它应该返回 a + b 的值。评分系统会调用该函数并验证返回值是否与预期一致。\n打印输出： 默认情况下，ok autograder 会忽略 print 语句的输出，因为它只关心返回值。如果有调试信息打印出来，最好使用特殊前缀（如 DEBUG:）或者注释符号（如 #），以避免误判为程序的正常输出。\nJuly 6, 2025 昨天听了Lecture 4 Higher-Order Functions然后顺手把hw02做了，后来考虑时间已晚于是就把project hog放在了第二天\nproject hog做了5个多小时，但是在读代码和写代码的过程中感觉自己的理解代码的能力提升了很多；而且完成这个项目，然后成功运行之后感受到了一种前所未有的成就感。我想这两点是CS61A作为UC Berkeley大一课程所能很大程度帮助提升学生能力的地方，阅读高质量的代码十分有益于计算机新手，同时完成项目的成就感能够激励我们继续后面的学习\n另外值得一提的是hw02中的一些题目中解法为Curring，这是我之前从未见到的，也是我在这个lecture收获最大的，不过这几道题我最初并没能想到Curring的解法于是使用了return一个判断的思路\ne.g.\n1 2 3 4 5 6 7 8 9 10 11 12 13 def summation_using_accumulate(n, term): \u0026#34;\u0026#34;\u0026#34;Returns the sum: term(1) + ... + term(n), using accumulate. \u0026gt;\u0026gt;\u0026gt; summation_using_accumulate(5, square) # square(1) + square(2) + ... + square(4) + square(5) 55 \u0026gt;\u0026gt;\u0026gt; summation_using_accumulate(5, triple) # triple(1) + triple(2) + ... + triple(4) + triple(5) 45 \u0026gt;\u0026gt;\u0026gt; # This test checks that the body of the function is just a return statement. \u0026gt;\u0026gt;\u0026gt; import inspect, ast \u0026gt;\u0026gt;\u0026gt; [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body] [\u0026#39;Expr\u0026#39;, \u0026#39;Return\u0026#39;] \u0026#34;\u0026#34;\u0026#34; return n \u0026gt; 0 and term(n) + summation_using_accumulate(n - 1, term) 判断n \u0026gt; 0 可以限制递归的边界，而当判断为False时，就会返回0的值，前一级的结果就会加0。自认为也是一种解决方法\n当然题干里要求了using accumulate，所以我的答案并不标准合规，下面是标准答案\n1 2 3 4 5 6 7 8 9 10 11 12 13 def accumulate(fuse, start, n, term): \u0026#34;\u0026#34;\u0026#34;Return the result of fusing together the first n terms in a sequence and start. The terms to be fused are term(1), term(2), ..., term(n). The function fuse is a two-argument commutative \u0026amp; associative function. \u0026#34;\u0026#34;\u0026#34; total, k = start, 1 while k \u0026lt;= n: total, k = fuse(total, term(k)), k + 1 return total def summation_using_accumulate(n, term): \u0026#34;\u0026#34;\u0026#34;Returns the sum: term(1) + ... + term(n), using accumulate.\u0026#34;\u0026#34;\u0026#34; return accumulate(add, 0, n, term) 后面几天计划出去旅游，学习估计得暂停几天，期间在飞机上路途中打算听一下3b1b的微积分视频，为后面学习MIT18.01/18.02: Calculus做准备\nJuly 26, 2025 递归好难\nJuly 31, 2025 Lecture 11 Sequences, 最简单的一集哈哈\nLab03也挺简单的，基本都是关于列表的基础题目， 40min以内就能搞定\nLecture 12 Containers 也比较简单，这两节属于为后续打基础的课\nAugust 4, 2025 前后历时3天终于完成了project cats\n其中自认为比较难的一道题是Problem7，题干如下\n我的解法及中文注释如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def minimum_mewtations(typed, source, limit): if typed == source: # 如果typed和source相等就终止，也是递归的终止 return 0 if limit \u0026lt;= 0: # 如果最小步数大于limit就结束，此时最终return的值将是limit + 1 return 1 elif len(typed) == 0 or len(source) == 0: # 同上，递归的终止 return abs(len(typed) - len(source)) elif typed[0] == source[0]: # 判断第一位是否相同，相同就继续递归，不相同就考虑如下add，remove，substitute三种情况 return minimum_mewtations(typed[1:], source[1:], limit) else: add = minimum_mewtations(typed, source[1:], limit - 1) # 添加一个字符相当于typed不变，source变为从第1位开始 remove = minimum_mewtations(typed[1:], source, limit - 1) # 删去一个字符相当于source不变，typed变为从第1位开始 substitute = minimum_mewtations(typed[1:], source[1:], limit - 1) # 替换一个字符相当于typed和source都不变，于是都变为下一位开始递归 return 1 + min(add, remove, substitute) # 取最小值 September 3, 2025 拖了好久终于把Project Ants写好了\n不得不承认通过完成一个项目能够很大程度提升对面对对象编程的理解\nSeptember 8, 2025 我认为该篇博客不应该尽局限于记录自身学习CS61A的感受，而应当聚焦于记录课程的知识点和题解，以供未来的自己和他人参考学习。故决定从今日起改变博客内容。\nLecture23 Measuring Efficiency 关于如何理解程序运行需要多长时间的问题\n如何计数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def fib(n): if n == 0 or n == 1: return n else: return fib(n - 2) + fib(n - 1) def count(f): def counted(n): counted.call_count += 1 return f(n) counted.call_count = 0 return counted \u0026#34;\u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; fib = count(fib) # 也可以通过decorator的方式实现 \u0026gt;\u0026gt;\u0026gt; fib(5) 5 \u0026gt;\u0026gt;\u0026gt; fib.call_count 15 \u0026#34;\u0026#34;\u0026#34; Memoization\n一种加速程序运行时间的技术， Idea: Remember the results that have been computed before\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def memo(f): cache = {} # Keys are arguments that map to return values def memoized(n): if n not in cache: cache[n] = f(n) return cache[n] return memoized # Same behavior as f, if f is a pure function \u0026#34;\u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; fib = count(fib) \u0026gt;\u0026gt;\u0026gt; counted_fib = fib \u0026gt;\u0026gt;\u0026gt; fib = memo(fib) \u0026gt;\u0026gt;\u0026gt; fib = count(fib) \u0026gt;\u0026gt;\u0026gt; fib(30) 832040 \u0026gt;\u0026gt;\u0026gt; fib.call_count 59 \u0026gt;\u0026gt;\u0026gt; counted_fib.call_count 31 \u0026#34;\u0026#34;” $$ b^n = \\left\\{ \\begin{array}{l} 1 \\qquad\\quad\\ \\ if\\ n = 0 \\\\ b \\cdot b^{n-1} \\quad otherwise \\end{array} \\right. $$$$ b^n = \\left\\{ \\begin{array}{l} 1 \\qquad\\quad\\ \\ if\\ n = 0 \\\\ (b^{\\frac{1}{2}n})^{2} \\quad \\ if\\ n\\ is\\ even \\\\ b \\cdot b^{n-1} \\quad if\\ n\\ is\\ odd \\end{array} \\right. $$","date":"2025-07-04T12:56:35+08:00","permalink":"https://ZihaoLin111.github.io/blog/p/cs61a%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","title":"CS61A学习日记"},{"content":"正如标题所言，之所以创立这个博客就是想有个地方能让我写一些关于刚刚过去的高考的感想。几天过去，我对于成绩依旧有很多想说的，但不知从何处说起，也不知同谁说。或许写下来是最好的方式。\n既然不知何处说起，那就从高考成绩本身开始吧\n查分前几天，我的港中深综评差0.1分没入围（关于综评，后面应该会详细写），当时老师同学都安慰我能去更好的层次的学校，于是查分当晚我一直期盼着自己能考个高分650或660这样的，当然这也不完全是幻想，因为我确实觉得数物化生考的还行，而语文英语也相信高考给分肯定会比平时多。\n查分时，我本想用书遮住一点点看，但不慎露出的609犹如晴天霹雳使我愣在当场，我想过会考差，因为模考排名一直就那样，但我没想到会如此差。我已不知当时脑子里是什么感受，震惊？懊恼？后悔？不甘？我试图强忍着镇定接受，实际心里却是痛苦。写到这，我不知道该怎么将这种痛苦展现出来，三言两语也说不清，就让后面的内容来一点点体现吧。当横跨几日的万千思绪汇聚在一起时，那便是我这一瞬刻骨铭心的痛苦感受。\n语文 我的语文一直不好，从小学到初中再到高中，题目大抵都能写出来一点，但总是写不全；文言文古诗也常常是看得一知半解；作文那便更是糟糕。（不过中考倒是意想不到地考好了一次，让我来了金中）上高中之后语文一直挺挣扎的，高一高二一直是五六百名徘徊的水平，上了高三之后有所改善，也是到了年级班级均分左右，几次模考虽然不是特别优秀但也至少说的过去，当时高考目标是达到均分就算成功（据说往年学校均分有115）。\n直到高考\u0026hellip;\u0026hellip;不得不承认今年高考语文是挺难的，记得那天下午四个同学做在一起：同学1：“你觉得语文难吗？”同学2：“废话，你没考吗？”看见我和同学3把耳朵捂住后他们俩也就没再聊了，现在回想起来还是忍不住笑，哈哈。\n但是写那张卷子期间却是一点也笑不出来，前两个现代文题型很创新，都快把我创死了，问答题是完全不知道在哪找踩分点，只能自己基于文章再天马行空的写答案，不过此时我还不是特别慌，因为向来现代文都写的不算差，千奇百怪的踩分点也不是没想到过。\n然后来到了文言文，断句不多说，几乎稳定拿分；字词\u0026hellip;不会，文义\u0026hellip;不会，前几年高考和模考的这两道题不是都是能找到明显错误吗？怎么今年的这么抽象！？看了好久选不出来，只好相信直觉，选了顺眼的以免耽误后面的了；翻译\u0026hellip;额，怎么也不会！？两个翻译都只写了一半，后一半完全不会，瞎猜也不知道怎么猜，老师教的、网上看的技巧都用不出来，此时我已经近乎崩溃了，因为几次模考我的翻译都至少能拿个五六分，这次可能三分都是奢望；最后的概括题依旧是没思路，抱着靠改卷老师捞的心态瞎写了点上去。\n后面的古诗阅读依旧是看不懂加不会，我已不想过多回忆细节，以免加深痛苦。\n理解性默写？我自认为写的是对的（一直没对答案），这一环节的得分与否我也不是特别在意。因为我确实有很多是不会背的，我不擅长背诵，高三我就不想把太多时间花在背这些东西上，总觉得性价比不高，于是我想出了全新的策略：我靠刷大量的理解性默写题，记住名句、找到题感，后来看到题目脑子里几乎就能瞬间蹦出答案来了。所以说既然没有付出和其他同学相同的精力，那我也就不强求自己这道题拿满分了。\n语用题我已经记不太清了，好像写的还行？没有考到我不擅长的成语、错别字之类的就已经很开心了。哦对好像有个提纲题纠结了一会，除此之外听说选成语的那道题有点争议，但我也没对过答案，所以就不纠结了。\n作文嘛，题目确实抽象，不过老师考前给我讲过抗战胜利80周年的题目，个人认为也算是押中了，所以作文大体还是会写的应该没有跑题，但是也仅限大体上，细节上的论点啊、论据啊还是一头雾水。当时抱着相信老师说高考作文给分会比平常高的心态硬着头皮写下去了。现在从结果看嘛，呵呵。\n出分前一直以为自己就算考不了那么高，至少100到110也是有的，这95分实在是让我震惊。后来还听说了什么压分、两个改卷组一严一松的，唉，只得引用网上的梗感叹——我大抵是被“做局”了。\n今天就写到这里，本来以为一会就能写完，但写起来发现还有那么多想说的，各科成绩啊、学校选择啊、还有对4班李同学的暗恋\u0026hellip;慢慢写吧，但愿以后还能想起现在的这些所思所想\n数学 哈哈，一直以来最擅长的学科，也是背刺的最大的学科。上高中以来，我就没怎么认真学习过数学，准确来说上高中前就不怎么认真学了，在校内外上上课，完成作业，然后我数学考试就能考的很高，虽然是比不过学校里那些清北华五选手，但和剩下的700多人相比也算的上优秀，每次大考数学基本上是年级前100，有时最后压轴题写的好就是年级前50的水平，周测也曾考过140+，年级前五\n考数学我有个习惯，就是写的很慢，写完每道题我都会再回看一遍，确保没有出错；然后就是几乎每道题都认真算，不会凭感觉，凭结论直接得出答案；最后是多选题从不猜答案，只选自己坚定的，因为我认为我的成绩不应该依赖于毫无逻辑的“赌博”\n得益于这个习惯，我每次考试的选填几乎不扣分，这也是我平日里数学好的原因。不过高考的时候却犯了特别大意的失误，一个是向量的选择题，一个是填空题的正负2，还有一个是填空最后一题计算错误。\n当然这次高考数学期间我的心态却有很大问题，前一个小时的题目都很简单以至于我有信心这次也能135+乃至140。直到19(1)，这道题我一时没有看出来答案，又因为我喜欢把所有东西算出来的习惯，我便开始执着地求导和计算，涉及三角函数的导数题我一直不擅长，所以我便越写越慌，过去了仅20分钟，我还执着于这道小题。此时我决定先写后面的题目，我把19(2)花了一点时间做出来了，然后果断放弃19(3)，现在还剩大约15分钟，我回头继续纠结19(1)，但由于心态的变化已经忘了猜那几个标志性的三角函数值，直到考试快结束才还是猜，甚至还猜错了答案。\n如果我没有在19(1)上耗费这么多时间，我的心态或许就不会变得那么差，我或许就有足够的时间回去检查前面的题，或许就能够发现我的错误。。。\n英语 至今没有对答案。说实话我觉得今年比往年难，当然也可能是我自己真的水平太差了，反正我的成绩远不如我们学校的平均水平，这一门我真的不知道该说些什么，每次阅读总感觉能读懂但就是写不对\n物理 这门也没什么好说的，三年来我的物理成绩起起伏伏，记得高一刚入学的时候我物理成绩极好，被老师邀请在班会课上分享学习经验，后来高二时好时坏，高三几次模考都不尽人意，于是花了段时间针对性地刷物理题，最后的结果也算是对的起三年的学习\n化学生物 最令我诧异也是最drama的两门。这两门我学的一直不好，考好的次数屈指可数。高三下学期的半年里，我的复习策略就是着重于这两门，报名了化学生物的一对一，一直不停刷这两门的试卷，以至于几乎放弃数学的学习，但是每次模考还是考的不好。后来我已经不抱希望了，认为这两门最后肯定是考不好了，结果没想到反而还靠这两门拉分了。我的物化生三门真算是考的很好了，考完那几天我都没见到有人比我高的(清北华五选手除外)，举个极端的例子，我们学校的文科状元的政史地三门也是278分，和我的物化生三门一样高，真的难以理解为何这样的物化生成绩会遇上发挥如此失常的语数外\n今天依旧先写到这，现在志愿填完了，后面应该有更多的闲暇时间用来更新博客了\n今天是2025年7月18日，好吧我承认我拖延症又犯了，距离上次写已经过去好久。人们说，高考失利就像一场漫长的雨季，前短时间似乎已经缓解，但是潮湿却在今天反扑过来。今天是出录取结果的日子\n","date":"2025-06-26T23:25:30+08:00","permalink":"https://ZihaoLin111.github.io/blog/p/%E5%88%9B%E7%AB%8B%E8%AF%A5%E5%8D%9A%E5%AE%A2%E5%88%9D%E8%A1%B7%E4%B8%8E%E5%85%B3%E4%BA%8E%E9%AB%98%E8%80%83%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/","title":"创立该博客初衷与关于高考的碎碎念"},{"content":"Test Hello World\nAugust 9th\n","date":"2025-06-26T12:26:16+08:00","permalink":"https://ZihaoLin111.github.io/blog/p/test/","title":"Test"}]